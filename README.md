# Эмуляция кластера

### О приложении

Приложение эмулирует работу кластера в котором ноды посылают друг другу сообщения. Каждая нода знает о всех других.
Нода каждые `tick-duration` выбирает случайную доступную ноду из кластера (исключая себя) и отправляет ей сообщение. По умолчанию `tick-duration` равен 100мс, число нод равно двум.

### Сборка и запуск

Нам потребуется scala версии 2.11.8, sbt версии 0.13.8, jdk версии 1.8.0_111 или свежее.<br>
Для сборки приложения - находясь в корневой директории с проектом выполнить из командной строки команду:<br>
```sh
sbt assembly
```
в результате будет собран файл `cluster-emulation-assembly-1.0.jar`

Для запуска приложения - находясь в директории с `cluster-emulation-assembly-1.0.jar` выполнить команду:<br>
```sh
java -jar cluster-emulation-assembly-1.0.jar
```

Если при выполнении этой инструкции у вас возникли какие-то проблемы - свяжитесь в скайпе с strana_oz. Он поможет справиться с возникшими проблемами и дополнит эту инструкцию.

В результате успешного запуска в консоле появятся сообщения от работающего приложения и по адресу `localhost:8080` будет доступно Rest API.

### Rest API

URL `host:port/cluster/nodes`<br>
Метод `get` возвращает список активных нод и детальную информацию о их состоянии<br>
Пример:<br>
```sh
curl localhost:8080/cluster/nodes
{
  "nodes": [{
    "availableNodes": ["node-2"],
    "processedForPreviousSecond": 10,
    "tickDelay": "100 milliseconds",
    "id": 1,
    "status": "active",
    "oneMinuteRate": 10.0,
    "meanRate": 10.018774548743416
  }, {
    "availableNodes": ["node-1"],
    "processedForPreviousSecond": 10,
    "tickDelay": "100 milliseconds",
    "id": 2,
    "status": "active",
    "oneMinuteRate": 10.0,
    "meanRate": 10.018769533897089
  }]
```

URL `host:port/cluster/nodes`<br>
Метод `post` с параметром `count` в `formFields` создает в кластере новые ноды.<br>
Пример добавления одной ноды:<br>
```sh
curl -d "count=1" localhost:8080/cluster/nodes
```
С помощью `get` запроса можно увидеть новую ноду с id=3

URL `host:port/cluster/nodes/{id}`<br>
Метод `delete` останавливает ноду с идентификатором `{id}`<br>
Пример остановки ноды с id=1<br>
```sh
curl -X "DELETE" localhost:8080/cluster/nodes/1
```

URL `host:port/cluster`<br>
Метод `patch` с параметром `tick-duration` в `json` изменяет значение задержки между посылкой сообщений в кластере.
Пример установки отправки сообщения каждые 2 секунды:<br>
```sh
curl --data '{"tick-duration": 2000}' --header "Content-Type: application/json" --request PATCH localhost:8080/cluster
```

### Ответы на вопросы из тестового задания

 - *оценить количество сообщений обрабатываемых в секунду каждой нодой*:<br>
 Нода отправляет сообщение другой случайной ноде из кластера, следовательно, одна нода в среднем каждый тик будет получать одно сообщение.
 В секунду это 1с/<длительность_тика>, при значениях по умолчанию будет 1/0.1 = 10 сообщений.
 Есть вероятность что все ноды отправят сообщение кому-то одному, чем больше нод в кластере, тем меньше эта вероятность.
 - *оценить предел производительности системы. Пределом можно считать, параметры системы, при которых добавление новых нод или сокращение интервала отправки сообщений не приводит к росту сообщений, обрабатываемых в секунду*:<br>
 Написать точную формулу из которой можно получить конкретное число будет трудно, т.к. формула будет зависеть от очень большого числа параметров.
 Но можно описать закономерности и зависимость от основных ресурсов.<br>
**Сеть**. Кластер из двух нод и 100мс в теории обрабатывает в секунду 20 сообщений. Но если сообщения очень тяжелые,
 а сеть очень медленная, к примеру, пропускная способность сети - 1 сообщение/секунду, то и производительность кластера будет всего 1 сообщение/сек.<br>
 **Память**, **процессор**, **диск**. Для формирования сообщения, его отправки и обработки используются: память,
 процессор и возможно взаимодействие с диском. К примеру, на обработку одного сообщения требуется 50мс (последовательная обработка),
 следовательно нет смысла отправлять сообщения чаще чем раз в 50мс, т.к. они не будут успевать обрабатываться.
 Процессим сообщения параллельно и ограничения по процессору нет - могут быть ограничения по памяти, как много сообщений позволит нам принять память?<br>
 Пока мы не встретили ограничения по сети, пямяти, процессору или диску число обрабатываемых сообщений в секунду будет равно <число нод> / <время тика в секундах> сообщений/секунду.
 - *Написать тесты на код, который ты считаешь критичным*:
 Внутри приложения нет сложной логики, которую хотелось бы протестировать юнит тестами. На мой взгляд весь функционал системы является "критичным", т.е. если его не страшно поломать или потерять - этот функционал не нужен, его следует удалить и не тратить силы, время на его поддержание. Будь это "боевая" задача, то весь функционал: "просмотр информации о нодах", "добавление ноды", ... я бы покрыл функциональными тестами. Реализовать функ. тесты для тестового задания, мне кажется, перебор :)
 - *Описать потенциальные тонкие места системы (Что будет, если упадет сеть, одна из нод съест весь ресурс процессора):*<br>
 *Сеть*. [Тут](http://doc.akka.io/docs/akka/2.4/scala/remoting.html#Failure_Detector) AKKA говорит что использует heartbeat и обещает отправлять `Terminated`
 в случае проблем с сетью или краша JVM. Как это повлияет на работу нашего кластера? Если у нас всего 2 ноды и возникла проблема с сетью - ноды получат `Terminated` и работа встанет.
 Если есть третья доступная нода (или несколько доступных нод) - работа продолжится без потерь производительности. Т.е. пока нодам есть кому слать
 (availableNodes не пустой) сообщения будут отправляться. В случае если проблема с сетью устранена и с нодами все в порядке их взаимодействие самостоятельно не восстановится.
 Попробовать решить эту проблему можно, например, следующим способом: различать запланированную (graceful) остановку и технические проблемы разными сообщениями.
 Если пришел GracefulTerminated, то удаляем ноду из availableNodes на совсем. Если пришел Terminated, то предполагаем, что это техническая проблема и ждем ее решения,
 т.е. из availableNodes убираем, но периодически пытаемся связаться с этой нодой в ожидании ее восстановления.<br>
 *Процессор*. К примеру, ноды разнородны, одна железка значительно слабее (память, процессор) остальных. Нода работает медленно, очередь сообщений на обработку копится.
 В этой реализации используется `UnboundedMailbox` (подробности [тут] (http://doc.akka.io/docs/akka/2.4/scala/mailboxes.html)),
 Unbounded - название говорит, что сообщения будут копиться пока не кончится память. В каком-то реальном примере лучше это мониторить
 и иметь запас прочности. Если нода слабая, а сообщения однотипны - можно использовать более умную стратегию отправки сообщений.
 Например, не на случайную ноду, а с учетом веса (производительности).<br>
 Описать другие потенциально тонкие места затруднительно. Они будут зависеть от реальной "полезной" задачи (пересылать сообщения между нодами не кажется полезной :)).
 Одна задача, это, например, если нам нужно просто масштабироваться по вычислениям. Тогда нам нужен балансировщик и ноды которые будут производить вычисления. Нодам знать друг о друге не нужно.
 Другая задача, это, например, если нам нужно распараллелить выполнение одной, но очень тяжелой задачи. Тогда нам следует посмотреть как реализован spark. И так далее.

### Прочие комментарии

- *Необходимо на базе AKKA remote*<br>
От AKKA remote тут используется только akka.actor.provider = remote. Не знаю правильно это или нет, т.к. никаких специальных указаний на этот счет в описании задачи нет.

- *Сделать описание для обслуживающего админа (непрограммиста)*<br>
 Не знаю насколько эта инструкция полная. Наверно, зависит от того насколько админ "непрограммист" :)
 В моей предыдущей команде за деплой и эксплуатацию отвечали сами разработчики. Для сборки и деплоя мы делали соответствующие "кнопки" на CI

- У get запроса по урлу `/cluster/nodes` нет пагинации, при большом количестве нод может работать медленно.

- Количество сообщений за последний тик это параметр `processedForPreviousSecond`. Если время тика будет больше 1 секунды - этот параметр будет не информативен.
 По этой причине дополнительно добавил - `meanRate` среднее за все время,  `oneMinuteRate` - exponentially-weighted moving average (среднее, но наибольший вес имеют последние данные).

- *Описание рест апи с помощью curl примеров*.<br>
 По хорошему нужно что-то вроде raml'а или swagger, но это потребовало бы значительно большего времени.

- В коде есть некоторые неидеально реализованные моменты, например:<br>
 - при добавлении новых нод мы отправляем уже существующим нодам не только новые, но и все старые<br>
 - при смене времени тика и остановки ноды мы не дожидаемся ответа что операция прошла успешно<br>
 - `ClusterManager` не наблюдает за нодами (не используется watch). Если удаленная нода упадет в результате краша JVM, то
 при добавлении новых нод `ClusterManager` будет отсылать "мертвые" ноды как активные. Для нод это не будет проблемой, т.к. watch над остановленным актором даст `Terminated`<br>

 Для тестового задания мне они показались не критичными, в ходе рабочего процесса их всегда можно обсудить во время код ревью.
